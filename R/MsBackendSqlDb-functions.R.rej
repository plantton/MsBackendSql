diff a/R/MsBackendSqlDb-functions.R b/R/MsBackendSqlDb-functions.R	(rejected hunks)
@@ -1,20 +1,41 @@
 #' @include hidden_aliases.R
 NULL
 
+#' @param dbcon a `DBIConnection` object to connect to the database.
+#'
 #' @rdname MsBackendSqlDb
 #'
 #' @importFrom methods is new
+#' 
+#' @importMethodsFrom DBI dbConnect 
+#' 
+#' @importFrom RSQLite SQLite
 #'
-#' @export
-MsBackendSqlDb <- function() {
-    new("MsBackendSqlDb")
+#' @export MsBackendSqlDb
+MsBackendSqlDb <- function(dbcon) {
+    if (!requireNamespace("DBI", quietly = TRUE))
+        stop("The use of 'MsBackendSqlDb' requires package 'DBI'. Please ",
+             "install with 'install.packages(\"DBI\")'")
+    if (missing(dbcon)) {
+        x <- new("MsBackendSqlDb")
+        slot(x, "dbcon", check = FALSE) <- dbConnect(SQLite(), 
+                                               tempfile(fileext = ".db"))
+        return(x)
+    } else {
+      x <- new("MsBackendSqlDb")
+      slot(x, "dbcon", check = FALSE) <- dbcon
+      return(x)
+    }
 }
 
 #' Test if db table is available
 #'
 #' @param dbcon [`DBIConnection-class`] object
+#' 
 #' @param dbtable `character(1)`, table name
+#' 
 #' @author Johannes Rainer, Sebastian Gibb
+#' 
 #' @noRd
 .valid_db_table_exists <- function(dbcon, dbtable) {
     if (!dbExistsTable(dbcon, dbtable))
@@ -84,20 +105,36 @@ MsBackendSqlDb <- function() {
     .write_data_to_db(hdr, con = con, dbtable = dbtable)
 }
 
-#' @importFrom DBI dbExecute dbAppendTable dbExistsTable dbDataType
+#' Helper function: will initiate a SQLite table `dbtable` in the SQLite 
+#' database with defined column types. SQLite database uses a dynamic type 
+#' system, which means if we simply copy a SQLite table into another SQLite 
+#' database, the column types will be lost. So we have to create the column 
+#' types for the copied table.
+#' 
+#' @param x data used to initiate a SQLite table in the database,
+#'  `data.frame` format.
+#' 
+#' @param con [SQLiteConnection] object linking to the SQLite database file.
+#' 
+#' @param dbtale character vector containing SQLite table name.
+#'
+#' @importFrom DBI dbExecute dbExistsTable dbDataType
 #'
 #' @importFrom MsCoreUtils vapply1l
+#' 
+#' @author Johannes Rainer, Chong Tang
 #'
 #' @noRd
-.write_data_to_db <- function(x, con, dbtable = "msdata") {
+.initiate_data_to_table <- function(x, con, dbtable = "msdata") {
     basic_type <- c("integer", "numeric", "logical", "factor", "character")
     is_blob <- which(!vapply1l(x, inherits, basic_type))
     for (i in is_blob) {
         x[[i]] <- lapply(x[[i]], base::serialize, NULL)
     }
     if (!dbExistsTable(con, dbtable)) {
+        x <- as.data.frame(x)
         flds <- dbDataType(con, x)
-        if (inherits(con, "SQLiteConnection"))
+        if (inherits(con, "SQLiteConnection")) 
             flds <- c(flds, `_pkey` = "INTEGER PRIMARY KEY")
         else stop(class(con)[1], " connections are not yet supported.")
         ## mysql INT AUTO_INCREMENT
@@ -106,6 +143,14 @@ MsBackendSqlDb <- function() {
                            collapse = ", "), ")")
         res <- dbExecute(conn = con, qr)
     }
+    x
+}
+
+#' @importFrom DBI dbAppendTable
+#'
+#' @noRd
+.write_data_to_db <- function(x, con, dbtable = "msdata") {
+    x <- .initiate_data_to_table(x, con, dbtable)
     dbAppendTable(conn = con, name = dbtable, x)
 }
 
@@ -229,37 +274,268 @@ MsBackendSqlDb <- function() {
     } else rep(TRUE, length(object))
 }
 
+#' Helper function to combine backends that base on [MsBackendSqlDb()]. If 
+#' `dbcon` is provided, the merged `MsBackendSqlDb` instance will be initiated
+#' by this `dbcon`. If `dbcon` is missing, the merged object will be stored in
+#' `tempdir()` directory.
+#'
+#' @param objects `list` of `MsBackend` objects.
+#' 
+#' @param dbcon a `DBIConnection` object used to initiate a new 
+#' `MsBackendSqlDb` instance, as the merged SQLite backend result.
+#' 
+#' @importFrom MsCoreUtils vapply1c 
+#'
+#' @return [MsBackendSqlDb()] object with combined content.
+#'
+#' @author Chong Tang
+#'
+#' @noRd
+.combine_backend_SqlDb <- function(objects, dbcon) {
+    if (length(objects) == 1)
+        return(objects[[1]])
+    if (!all(vapply1c(objects, class) == class(objects[[1]])))
+        stop("Can only merge backends of the same type: ", class(objects[[1]]))
+    spcVar <- lapply(objects, function(z) spectraVariables(z))
+    if (!length(unique(spcVar)) == 1)
+        stop("Can only merge backends with the same spectra variables.")
+    res <- .clone_MsBackendSqlDb(objects[[1]], dbcon)
+    for (i in 2:length(objects)) {
+        res <- .attach_migration(res, objects[[i]])
+    }
+    res
+}
 
+#' Helper function for schema migration, which will use `ATTACH` statement
+#' to transfer a SQLite table to another SQLite database, then use `DETACH`
+#' statement to remove the attached database.
+#' 
+#' @param x [MsBackendSqlDb()] object will hold the migrated table.
+#' 
+#' @param y [MsBackendSqlDb()] object will be attached to `x`.
+#' 
+#' @importFrom DBI dbGetQuery dbExecute dbSendStatement dbClearResult
+#' 
+#' @author Chong Tang
+#' 
+#' @noRd
+.attach_migration <- function(x, y) {
+    ## If `x` and `y` are sharing the same dbfile, and using the same dbtable
+    if (identical(x@dbcon@dbname, y@dbcon@dbname) && 
+        identical(x@dbtable, y@dbtable)) {
+        x@rows <- c(x@rows, y@rows)
+        x@modCount <- unlist(c(x@modCount, y@modCount),
+                             use.names = FALSE)
+        return(x) } else if (identical(x@dbcon@dbname, y@dbcon@dbname) && 
+        (!identical(x@dbtable, y@dbtable))) {
+        ## If `x` and `y` are sharing the same dbfile, and using different dbtable
+        ## We want to know the length (row numbers) of x@dbtable
+        x_length <- dbGetQuery(x@dbcon, paste0("SELECT COUNT(*) FROM ", 
+                                               x@dbtable))
+        x_length <- x_length[, 1]
+        ## Insert y@dbtable into x@dbtable, they have the same dbcon obj
+        qry <- dbSendStatement(x@dbcon, paste0("INSERT INTO ", x@dbtable, " (", 
+                                               paste(spectraVariables(x), 
+                                                     collapse = ", "), ") ",
+                                               " SELECT ", 
+                                               paste(spectraVariables(y), 
+                                                     collapse = ", "), 
+                                               " FROM ", y@dbtable))
+        dbClearResult(qry)
+        ## modify X@rows, the inserted rows will be added
+        ## into the tail of x@rows
+        x@rows <- unlist(c(x@rows, y@rows + x_length))
+        x@modCount <- unlist(c(x@modCount, y@modCount),
+                             use.names = FALSE)
+        return(x) } else {
+        ## While x and y have different db files.
+        ## We want to know the length (row numbers) of x@dbtable
+        x_length <- dbGetQuery(x@dbcon, paste0("SELECT COUNT(*) FROM ", 
+                                               x@dbtable))
+        x_length <- x_length[, 1]
+        ## Use `ATTACH` statement to migrate y@dbtable to the db file of x
+        dbExecute(x@dbcon, paste0("ATTACH DATABASE '",
+                                  y@dbcon@dbname, "' AS toMerge"))
+        st <- dbSendStatement(x@dbcon, paste0("insert into ", x@dbtable, " (", 
+                                              paste(spectraVariables(x), 
+                                              collapse = ", "), ") ",
+                                        "select ", paste(spectraVariables(y), 
+                                              collapse = ", "), 
+                                            " from toMerge.", y@dbtable))
+        suppressWarnings(dbExecute(x@dbcon, "DETACH DATABASE toMerge"))
+        ## modify X@rows, the inserted rows will be added
+        ## into the tail of x@rows
+        x@rows <- unlist(c(x@rows, y@rows + x_length))
+        x@modCount <- unlist(c(x@modCount, y@modCount),
+                             use.names = FALSE)
+        return(x) 
+       }
+}
 
+#' Helper function to clone a `MsBackendSqlDb` instance.
+#' 
+#' @param x [MsBackendSqlDb()] object to be cloned.
+#' 
+#' @importFrom DBI dbGetQuery dbExecute dbClearResult dbSendQuery
+#' 
+#' @author Chong Tang
+#' 
+#' @noRd
+.clone_MsBackendSqlDb <- function(x, dbcon) {
+    ## If `cbdbcon` is missing, we will create an empty `MsBackendSqlDb` 
+    ## Instance with its '.db' file in `tempdir()`.
+    if (missing(dbcon) || !dbIsValid(dbcon)) {
+        res <- MsBackendSqlDb()
+    } else {
+        res <- MsBackendSqlDb(dbcon)
+    }
+    slot(res, "dbtable", check = FALSE) <- x@dbtable
+    slot(res, "modCount", check = FALSE) <- x@modCount
+    slot(res, "rows", check = FALSE) <- x@rows
+    slot(res, "columns", check = FALSE) <- x@columns
+    slot(res, "readonly", check = FALSE) <- x@readonly
+    slot(res, "version", check = FALSE) <- x@version
+    ## If `dbtable` existed in the provided `dbcon` related database, remove it
+    if (!missing(dbcon) && dbIsValid(dbcon))
+        dbExecute(res@dbcon, paste0("DROP TABLE IF EXISTS ", res@dbtable))
+    ## Now we want to clone the SQLite table in `x`
+    if (length(x@dbtable)) 
+        ## Fetch the 1st row from `x@table`, we want to fetch the column types
+        row_1 <- dbGetQuery(x@dbcon, 
+                            paste0("SELECT * FROM ", x@dbtable, 
+                                   " WHERE _pkey = 1"))
+        ## remove the column:`_pkey`
+        row_1[names(row_1) %in% "_pkey"] <- NULL
+        ## initiate a SQLite table in the new `MsBackendSqlDb` instance 
+        ## with the same column types in x@dbtable
+        .initiate_data_to_table(row_1, res@dbcon, res@dbtable)
+        ## Now we copy `x@dbtable` to the SQLite database of `res`
+        dbExecute(res@dbcon, paste0("ATTACH DATABASE '",
+                                   x@dbcon@dbname, "' AS toMerge"))
+        st <- dbSendStatement(res@dbcon, paste0("insert into ", res@dbtable,
+                                                " (", 
+                                   paste(spectraVariables(x), 
+                                         collapse = ", "), ") ",
+                                   "select ", paste(spectraVariables(x), 
+                                                    collapse = ", "), 
+                                   " from toMerge.", x@dbtable))
+        suppressWarnings(dbExecute(res@dbcon, "DETACH DATABASE toMerge"))
+        res@query <- dbSendQuery(res@dbcon, paste0("select ? from ", 
+                                                   res@dbtable, 
+                                                   " where _pkey = ?"))
+        return(res)
+}
 
-#' Replace the columns from the database and ensure the right data type can be 
-#'   returned. 
+#' Replace the values of a SQLite table column, and ensure the right data type
+#'  can be returned. It's temporarily not in use.
+#'  I kept this function, since replacing column values in huge database is
+#'  extremely time consuming. It's more efficient to use the strategy here.
+#'  
+#'  
+#' @param x [MsBackendSqlDb()] object.
+#' 
+#' @param name A `character(1)` with the name of the column will be replaced.
+#' 
+#' @param value vector with values to replace the `name`.
 #'
-#' @importFrom DBI dbSendQuery dbExecute dbClearResult dbReadTable dbWriteTable
+#' @importFrom DBI dbSendQuery dbExecute dbClearResult dbReadTable dbWriteTable dbListFields
 #'
 #' @noRd
-.replace_db_table_columns <- function(object, column, value) {
-    str1 <- object@columns[object@columns != column]
+.replace_db_table_columns <- function(x, name, value) {
+    flds <- dbListFields(x@dbcon, "msdata")
+    str1 <- dbListFields(x@dbcon, "msdata")[dbListFields(x@dbcon, 
+                                                       "msdata") != name]
     sql1 <- paste0("CREATE VIEW metaview AS SELECT ",
-                   toString(str1), " FROM ", object@dbtable)
-    qry <- dbSendQuery(object@dbcon, sql1)
+                   toString(str1), " FROM ", x@dbtable)
+    qry <- dbSendQuery(x@dbcon, sql1)
     dbClearResult(qry)
     sql2 <- paste0("CREATE VIEW metakey AS SELECT ", "_pkey",
-                   " FROM ", object@dbtable)
-    qry2 <- dbSendQuery(object@dbcon, sql2)
+                   " FROM ", x@dbtable)
+    qry2 <- dbSendQuery(x@dbcon, sql2)
     dbClearResult(qry2)
-    metapkey <- dbReadTable(object@dbcon, 'metakey')
-    dbWriteTable(object@dbcon, 'token', 
-                 data.frame(value, pkey = metapkey))
+    metapkey <- dbReadTable(x@dbcon, 'metakey')
+    token <- data.frame(name = value, pkey = metapkey)
+    colnames(token) <- c(name, "pkey")
+    dbWriteTable(x@dbcon, 'token', token)
     sql3 <- paste0("CREATE TABLE msdata1 AS ", "SELECT * FROM metaview ",
-                   "INNER JOIN token on token._pkey = metaview1._pkey")
-    dbExecute(object@dbcon, sql3)
-    dbExecute(object@dbcon, paste0("ALTER TABLE ", object@dbtable,
-                                    " RENAME TO _msdata_old"))
-    dbExecute(object@dbcon, "ALTER TABLE msdata1 RENAME TO ", 
-              object@dbtable)
-    dbExecute(object@dbcon, "DROP TABLE IF EXISTS _msdata_old")
+                   "INNER JOIN token on token.pkey = metaview._pkey")
+    dbExecute(x@dbcon, sql3)
+    dbExecute(x@dbcon, paste0("ALTER TABLE ", x@dbtable,
+                              " RENAME TO _msdata_old"))
+    ## We have to sort `str2` into ordinary metadata order
+    sql2 <- paste0("CREATE TABLE msdata AS SELECT ",
+                   toString(flds), " FROM msdata1")
+    qry2 <- dbSendQuery(x@dbcon, sql2)
+    dbClearResult(qry2)
+    dbExecute(x@dbcon, "DROP TABLE IF EXISTS _msdata_old")
+    dbExecute(x@dbcon, "DROP TABLE IF EXISTS msdata1")
     ## Drop View
-    dbExecute(object@dbcon, "DROP TABLE IF EXISTS token")
-    dbExecute(object@dbcon, "DROP VIEW IF EXISTS metaview")
+    dbExecute(x@dbcon, "DROP TABLE IF EXISTS token")
+    dbExecute(x@dbcon, "DROP VIEW IF EXISTS metaview")
+    dbExecute(x@dbcon, "DROP VIEW IF EXISTS metakey")
+}
+
+#' Replace the values of a SQLite table column.
+#'  
+#' @param x [MsBackendSqlDb()] object.
+#' 
+#' @param name A `character(1)` with the name of the column will be replaced.
+#' 
+#' @param  value vector with values to replace the `name`.
+#'
+#' @importFrom DBI dbExecute dbSendStatement dbWriteTable dbClearResult
+#'
+#' @noRd
+.update_db_table_columns <- function(x, name, value) {
+    ## Fetch the table info: including column names and column types
+    typeTbl <- dbGetQuery(x@dbcon, "PRAGMA table_info(msdata)")
+    ## Check whether arg - `name` has type `BLOB` in SQLite table
+    ## The original design is to use any type to replace a column
+    ## e.g. the `mz`:BLOB column can even be replaced by integer()
+    if (name %in% typeTbl[typeTbl$type %in% "BLOB", ]$name)
+        value <- lapply(value, base::serialize, NULL)
+    table_y <- data.frame(name = I(value), pkey = x@rows)
+    colnames(table_y) <- c(name, "pkey")
+    dbWriteTable(x@dbcon, 'table_y', table_y)
+    state1 <- dbSendStatement(x@dbcon, paste0("UPDATE ", x@dbtable, " SET ",
+                                       name, " = (SELECT ", name, 
+                                       " FROM table_y WHERE pkey = _pkey)"))
+    dbExecute(x@dbcon, "DROP TABLE IF EXISTS table_y")
+    x
+}
+
+#' Insert values to a SQLite table as a new column, and ensure the right data
+#' type can be returned. 
+#'  
+#' @param x [MsBackendSqlDb()] object.
+#' 
+#' @param name A `character(1)` with the name of the column will be replaced.
+#' 
+#' @param value vector with values to replace the `name`.
+#'
+#' @importFrom DBI dbExecute dbSendStatement dbWriteTable dbClearResult
+#'
+#' @noRd
+.insert_db_table_columns <- function(x, name, value) {
+    if (is(value, "NumericList")) {
+        value <- lapply(value, base::serialize, NULL)
+        newType <- "BLOB"
+    } else {
+        newType <- dbDataType(x@dbcon, value)
+    }
+    ## Use ALTER statement to insert a new column in the table
+    state1 <- dbSendStatement(x@dbcon, paste0("ALTER TABLE ", x@dbtable,
+                                              " ADD ", name, " ", 
+                                              newType))
+    
+    table_y <- data.frame(name = I(value), pkey = x@rows)
+    colnames(table_y) <- c(name, "pkey")
+    dbWriteTable(x@dbcon, 'table_y', table_y)
+    ## UPDATE the rows of new column - "name", where _pkey = x@rows
+    state2 <- dbSendStatement(x@dbcon, paste0("UPDATE ", x@dbtable, " SET ",
+                                              name, " = (SELECT ", name, 
+                                              " FROM table_y WHERE pkey = _pkey)"))
+    dbExecute(x@dbcon, "DROP TABLE IF EXISTS table_y")
+    slot(x, "columns", check = FALSE) <- c(x@columns, name)
+    x
 }
\ No newline at end of file
